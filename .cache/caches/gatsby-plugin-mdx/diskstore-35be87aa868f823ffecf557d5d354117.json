{"expireTime":9007200844352714000,"key":"gatsby-plugin-mdx-entire-payload-6fad4066bf5e288a25eb14706744f9fd-","val":{"mdast":{"type":"root","children":[{"type":"paragraph","children":[{"type":"text","value":"The ","position":{"start":{"line":1,"column":1,"offset":0},"end":{"line":1,"column":5,"offset":4},"indent":[]}},{"type":"strong","children":[{"type":"text","value":"Ramer-Douglas–Peucker Algorithm","position":{"start":{"line":1,"column":7,"offset":6},"end":{"line":1,"column":38,"offset":37},"indent":[]}}],"position":{"start":{"line":1,"column":5,"offset":4},"end":{"line":1,"column":40,"offset":39},"indent":[]}},{"type":"text","value":" is a an algorithms that reduce the number of points that is approximated by a series of points. It is also known as the ","position":{"start":{"line":1,"column":40,"offset":39},"end":{"line":1,"column":161,"offset":160},"indent":[]}},{"type":"strong","children":[{"type":"text","value":"Douglas–Peucker algorithm","position":{"start":{"line":1,"column":163,"offset":162},"end":{"line":1,"column":188,"offset":187},"indent":[]}}],"position":{"start":{"line":1,"column":161,"offset":160},"end":{"line":1,"column":190,"offset":189},"indent":[]}},{"type":"text","value":" and ","position":{"start":{"line":1,"column":190,"offset":189},"end":{"line":1,"column":195,"offset":194},"indent":[]}},{"type":"strong","children":[{"type":"text","value":"iterative end-point fit algorithm","position":{"start":{"line":1,"column":197,"offset":196},"end":{"line":1,"column":230,"offset":229},"indent":[]}}],"position":{"start":{"line":1,"column":195,"offset":194},"end":{"line":1,"column":232,"offset":231},"indent":[]}},{"type":"text","value":". In simple words, it represent a complex line with fewer points in a visually proper way.","position":{"start":{"line":1,"column":232,"offset":231},"end":{"line":1,"column":322,"offset":321},"indent":[]}}],"position":{"start":{"line":1,"column":1,"offset":0},"end":{"line":1,"column":322,"offset":321},"indent":[]}},{"type":"heading","depth":3,"children":[{"type":"text","value":"Overview","position":{"start":{"line":3,"column":5,"offset":327},"end":{"line":3,"column":13,"offset":335},"indent":[]}}],"position":{"start":{"line":3,"column":1,"offset":323},"end":{"line":3,"column":13,"offset":335},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"The main purpose of this algorithm is to find a similar curve with fewer points for a given curve composed of line segments (also called ","position":{"start":{"line":5,"column":1,"offset":337},"end":{"line":5,"column":138,"offset":474},"indent":[]}},{"type":"strong","children":[{"type":"text","value":"Polylines","position":{"start":{"line":5,"column":140,"offset":476},"end":{"line":5,"column":149,"offset":485},"indent":[]}}],"position":{"start":{"line":5,"column":138,"offset":474},"end":{"line":5,"column":151,"offset":487},"indent":[]}},{"type":"text","value":"). This algorithm define 'disimilar' based on the maxium distance between the original curve and the simplied curve, i.e. the Hausdroff Distance. The Hausdroff distance is the longest distance you can be forced to travel by an adversary who chooses a point in one of the two sets, from where you then must travel to the other set. The simplified curve consist of a subset of points that defined the original curve.","position":{"start":{"line":5,"column":151,"offset":487},"end":{"line":5,"column":565,"offset":901},"indent":[]}}],"position":{"start":{"line":5,"column":1,"offset":337},"end":{"line":5,"column":565,"offset":901},"indent":[]}},{"type":"heading","depth":3,"children":[{"type":"text","value":"How It Works","position":{"start":{"line":9,"column":5,"offset":909},"end":{"line":9,"column":17,"offset":921},"indent":[]}}],"position":{"start":{"line":9,"column":1,"offset":905},"end":{"line":9,"column":17,"offset":921},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Traversing a linked list means going through every single node of Linked List from ","position":{"start":{"line":11,"column":1,"offset":923},"end":{"line":11,"column":84,"offset":1006},"indent":[]}},{"type":"inlineCode","value":"head","position":{"start":{"line":11,"column":84,"offset":1006},"end":{"line":11,"column":90,"offset":1012},"indent":[]}},{"type":"text","value":" of the Linked List to the node which has ","position":{"start":{"line":11,"column":90,"offset":1012},"end":{"line":11,"column":132,"offset":1054},"indent":[]}},{"type":"inlineCode","value":"next","position":{"start":{"line":11,"column":132,"offset":1054},"end":{"line":11,"column":138,"offset":1060},"indent":[]}},{"type":"text","value":" value pointing to None. Singly linked list can traversed in forward direction only starting from the first element.","position":{"start":{"line":11,"column":138,"offset":1060},"end":{"line":11,"column":254,"offset":1176},"indent":[]}}],"position":{"start":{"line":11,"column":1,"offset":923},"end":{"line":11,"column":254,"offset":1176},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"In the following program, we will print the the value of next data element by assigning the pointer of the next node to current data element :","position":{"start":{"line":13,"column":1,"offset":1178},"end":{"line":13,"column":143,"offset":1320},"indent":[]}}],"position":{"start":{"line":13,"column":1,"offset":1178},"end":{"line":13,"column":143,"offset":1320},"indent":[]}},{"type":"code","lang":"python","meta":null,"value":"class Node:\n    def __init__(self, dataval=None):\n        self.dataval = dataval\n        self.nextval = None\n\nclass CLinkedList:\n    def __init__(self):\n        self.headval = None\n\n    def listprint(self):\n        printval = self.headval\n        while printval is not None:\n            print (printval.dataval)\n            printval = printval.nextval\n\nlt= CLinkedList()\nlt.headval = Node(\"A\")\ne2 = Node(\"B\")\ne3 = Node(\"C\")\ne4 = Node(\"D\")\n\n# Link first Node to second node\nlt.headval.nextval = e2\n\n# Link second Node to third node\ne2.nextval = e3\n\n# Link third Node to fourth node\ne3.nextval = e4\n\nlt.listprint()","position":{"start":{"line":15,"column":1,"offset":1322},"end":{"line":47,"column":4,"offset":1948},"indent":[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"The output of the above code :","position":{"start":{"line":49,"column":1,"offset":1950},"end":{"line":49,"column":31,"offset":1980},"indent":[]}}],"position":{"start":{"line":49,"column":1,"offset":1950},"end":{"line":49,"column":31,"offset":1980},"indent":[]}},{"type":"code","lang":null,"meta":null,"value":"A\nB\nC\nD","position":{"start":{"line":50,"column":1,"offset":1981},"end":{"line":55,"column":4,"offset":1996},"indent":[1,1,1,1,1]}},{"type":"heading","depth":3,"children":[{"type":"text","value":"How to insert a New Node ?","position":{"start":{"line":59,"column":5,"offset":2004},"end":{"line":59,"column":31,"offset":2030},"indent":[]}}],"position":{"start":{"line":59,"column":1,"offset":2000},"end":{"line":59,"column":31,"offset":2030},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Depending upon the location where you want to insert an item , there are different ways to insert item in the linked list.","position":{"start":{"line":61,"column":1,"offset":2032},"end":{"line":61,"column":123,"offset":2154},"indent":[]}}],"position":{"start":{"line":61,"column":1,"offset":2032},"end":{"line":61,"column":123,"offset":2154},"indent":[]}},{"type":"heading","depth":4,"children":[{"type":"text","value":"Inserting at the beginning of the Linked List :","position":{"start":{"line":63,"column":6,"offset":2161},"end":{"line":63,"column":53,"offset":2208},"indent":[]}}],"position":{"start":{"line":63,"column":1,"offset":2156},"end":{"line":63,"column":53,"offset":2208},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"This involves pointing the next node of next data to the current head of the Linked List. As a result, the current head of the linked list will become the second data element and the new node becomes the head of the linked list.","position":{"start":{"line":65,"column":1,"offset":2210},"end":{"line":65,"column":229,"offset":2438},"indent":[]}}],"position":{"start":{"line":65,"column":1,"offset":2210},"end":{"line":65,"column":229,"offset":2438},"indent":[]}},{"type":"code","lang":"python","meta":null,"value":"class Node:\n    def __init__(self, dataval=None):\n        self.dataval = dataval\n        self.nextval = None\n\nclass CLinkedList:\n    def __init__(self):\n        self.headval = None\n\n# Print the linked list\n    def listprint(self):\n        printval = self.headval\n        while printval is not None:\n            print (printval.dataval)\n            printval = printval.nextval\n    def AtBegining(self,newdata):\n        NewNode = Node(newdata)\n\t\t# Update the new nodes next val to existing node\n        NewNode.nextval = self.headval\n        self.headval = NewNode\n\nlt = CLinkedList()\nlt.headval = Node(\"A\")\ne2 = Node(\"B\")\ne3 = Node(\"C\")\n\nlt.headval.nextval = e2\ne2.nextval = e3\n\nlt.AtBegining(\"Z\")\n\nlt.listprint()","position":{"start":{"line":67,"column":1,"offset":2440},"end":{"line":100,"column":4,"offset":3166},"indent":[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"The output of the above code :","position":{"start":{"line":102,"column":1,"offset":3168},"end":{"line":102,"column":31,"offset":3198},"indent":[]}}],"position":{"start":{"line":102,"column":1,"offset":3168},"end":{"line":102,"column":31,"offset":3198},"indent":[]}},{"type":"code","lang":null,"meta":null,"value":"Z\nA\nB\nC","position":{"start":{"line":103,"column":1,"offset":3199},"end":{"line":108,"column":4,"offset":3214},"indent":[1,1,1,1,1]}},{"type":"heading","depth":4,"children":[{"type":"text","value":"Inserting at the end of Linked List :","position":{"start":{"line":112,"column":6,"offset":3223},"end":{"line":112,"column":43,"offset":3260},"indent":[]}}],"position":{"start":{"line":112,"column":1,"offset":3218},"end":{"line":112,"column":43,"offset":3260},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"This involves pointing the next pointer of the current last node of the linked list to the new data. As a result, the current last node of the linked list becomes the second last node of the linked list and the new data node becomes the last node of the current linked list.","position":{"start":{"line":114,"column":1,"offset":3262},"end":{"line":114,"column":275,"offset":3536},"indent":[]}}],"position":{"start":{"line":114,"column":1,"offset":3262},"end":{"line":114,"column":275,"offset":3536},"indent":[]}},{"type":"code","lang":"python","meta":null,"value":"class Node:\n    def __init__(self, dataval=None):\n        self.dataval = dataval\n        self.nextval = None\n\nclass CLinkedList:\n    def __init__(self):\n        self.headval = None\n\n# Function to add newnode\n    def AtEnd(self, newdata):\n        NewNode = Node(newdata)\n        if self.headval is None:\n            self.headval = NewNode\n            return\n        laste = self.headval\n        while(laste.nextval):\n            laste = laste.nextval\n        laste.nextval=NewNode\n\n# Print the linked list\n    def listprint(self):\n        printval = self.headval\n        while printval is not None:\n            print (printval.dataval)\n            printval = printval.nextval\n\n\nlt = CLinkedList()\nlt.headval = Node(\"A\")\ne2 = Node(\"B\")\ne3 = Node(\"C\")\n\nlt.headval.nextval = e2\ne2.nextval = e3\n\nlt.AtEnd(\"Z\")\n\nlt.listprint()","position":{"start":{"line":116,"column":1,"offset":3538},"end":{"line":156,"column":4,"offset":4372},"indent":[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"The output of the above code :","position":{"start":{"line":158,"column":1,"offset":4374},"end":{"line":158,"column":31,"offset":4404},"indent":[]}}],"position":{"start":{"line":158,"column":1,"offset":4374},"end":{"line":158,"column":31,"offset":4404},"indent":[]}},{"type":"code","lang":null,"meta":null,"value":"A\nB\nC\nZ","position":{"start":{"line":159,"column":1,"offset":4405},"end":{"line":164,"column":4,"offset":4420},"indent":[1,1,1,1,1]}},{"type":"heading","depth":4,"children":[{"type":"text","value":"Inserting in between two Data Nodes :","position":{"start":{"line":168,"column":6,"offset":4429},"end":{"line":168,"column":43,"offset":4466},"indent":[]}}],"position":{"start":{"line":168,"column":1,"offset":4424},"end":{"line":168,"column":43,"offset":4466},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"This involves pointing the next pointer of the specific node to the new node.","position":{"start":{"line":170,"column":1,"offset":4468},"end":{"line":170,"column":78,"offset":4545},"indent":[]}}],"position":{"start":{"line":170,"column":1,"offset":4468},"end":{"line":170,"column":78,"offset":4545},"indent":[]}},{"type":"code","lang":"python","meta":null,"value":"class Node:\n    def __init__(self, dataval=None):\n        self.dataval = dataval\n        self.nextval = None\n\nclass CLinkedList:\n    def __init__(self):\n        self.headval = None\n\n# Function to add node\n    def Inbetween(self,middle_node,newdata):\n        if middle_node is None:\n            print(\"The mentioned node is absent\")\n            return\n\n        NewNode = Node(newdata)\n        NewNode.nextval = middle_node.nextval\n        middle_node.nextval = NewNode\n\n# Print the linked list\n    def listprint(self):\n        printval = self.headval\n        while printval is not None:\n            print (printval.dataval)\n            printval = printval.nextval\n\n\nlt = CLinkedList()\nlt.headval = Node(\"A\")\ne2 = Node(\"B\")\ne3 = Node(\"C\")\n\nlt.headval.nextval = e2\ne2.nextval = e3\n\nlt.Inbetween(lt.headval.nextval,\"Z\")\n\nlt.listprint()","position":{"start":{"line":172,"column":1,"offset":4547},"end":{"line":211,"column":4,"offset":5392},"indent":[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"The output of the above code :","position":{"start":{"line":213,"column":1,"offset":5394},"end":{"line":213,"column":31,"offset":5424},"indent":[]}}],"position":{"start":{"line":213,"column":1,"offset":5394},"end":{"line":213,"column":31,"offset":5424},"indent":[]}},{"type":"code","lang":null,"meta":null,"value":"A\nB\nZ\nC","position":{"start":{"line":214,"column":1,"offset":5425},"end":{"line":219,"column":4,"offset":5440},"indent":[1,1,1,1,1]}},{"type":"heading","depth":3,"children":[{"type":"text","value":"Removing  a Node from Linked List :","position":{"start":{"line":223,"column":5,"offset":5448},"end":{"line":223,"column":40,"offset":5483},"indent":[]}}],"position":{"start":{"line":223,"column":1,"offset":5444},"end":{"line":223,"column":40,"offset":5483},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"To remove a node from the Linked List , we need to traverse the the list until we find our target node. Then we will link the pointer of the previous node of the target node to the next node of the target node.","position":{"start":{"line":225,"column":1,"offset":5485},"end":{"line":225,"column":211,"offset":5695},"indent":[]}}],"position":{"start":{"line":225,"column":1,"offset":5485},"end":{"line":225,"column":211,"offset":5695},"indent":[]}},{"type":"code","lang":"python","meta":null,"value":"class Node:\n    def __init__(self, data=None):\n        self.data = data\n        self.next = None\n\nclass CLinkedList:\n    def __init__(self):\n        self.head = None\n\n    def Atbegining(self, data_in):\n        NewNode = Node(data_in)\n        NewNode.next = self.head\n        self.head = NewNode\n\n# Function to remove node\n    def RemoveNode(self, Removekey):\n\n        HeadVal = self.head\n\n        if (HeadVal is not None):\n            if (HeadVal.data == Removekey):\n                self.head = HeadVal.next\n                HeadVal = None\n                return\n\n        while (HeadVal is not None):\n            if HeadVal.data == Removekey:\n                break\n            prev = HeadVal\n            HeadVal = HeadVal.next\n\n        if (HeadVal == None):\n            return\n\n        prev.next = HeadVal.next\n\n        HeadVal = None\n\n    def LListprint(self):\n        printval = self.head\n        while (printval):\n            print(printval.data),\n            printval = printval.next\n\n\nllist = CLinkedList()\nllist.Atbegining(\"A\")\nllist.Atbegining(\"B\")\nllist.Atbegining(\"C\")\nllist.Atbegining(\"D\")\nllist.RemoveNode(\"B\")\nllist.LListprint()","position":{"start":{"line":227,"column":1,"offset":5697},"end":{"line":280,"column":4,"offset":6850},"indent":[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"When the above code is executed, it produces the following result:","position":{"start":{"line":282,"column":1,"offset":6852},"end":{"line":282,"column":67,"offset":6918},"indent":[]}}],"position":{"start":{"line":282,"column":1,"offset":6852},"end":{"line":282,"column":67,"offset":6918},"indent":[]}},{"type":"code","lang":null,"meta":null,"value":"A\nC\nD","position":{"start":{"line":283,"column":1,"offset":6919},"end":{"line":287,"column":4,"offset":6932},"indent":[1,1,1,1]}},{"type":"thematicBreak","position":{"start":{"line":291,"column":1,"offset":6936},"end":{"line":291,"column":4,"offset":6939},"indent":[]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Author","position":{"start":{"line":292,"column":4,"offset":6943},"end":{"line":292,"column":10,"offset":6949},"indent":[]}}],"position":{"start":{"line":292,"column":1,"offset":6940},"end":{"line":292,"column":10,"offset":6949},"indent":[]}},{"type":"blockquote","children":[{"type":"paragraph","children":[{"type":"text","value":"Hey, I’m Ayan, a backend software engineer. I write about what I know to help viewers like you. If you enjoy my content, please consider supporting what I do!","position":{"start":{"line":294,"column":2,"offset":6953},"end":{"line":294,"column":160,"offset":7111},"indent":[]}}],"position":{"start":{"line":294,"column":2,"offset":6953},"end":{"line":294,"column":160,"offset":7111},"indent":[]}},{"type":"paragraph","children":[{"type":"link","title":null,"url":"https://ko-fi.com/B0B81M1SZ","children":[{"type":"image","title":null,"url":"https://www.ko-fi.com/img/githubbutton_sm.svg","alt":"ko-fi","position":{"start":{"line":296,"column":3,"offset":7116},"end":{"line":296,"column":58,"offset":7171},"indent":[]}}],"position":{"start":{"line":296,"column":2,"offset":7115},"end":{"line":296,"column":88,"offset":7201},"indent":[]}}],"position":{"start":{"line":296,"column":2,"offset":7115},"end":{"line":296,"column":88,"offset":7201},"indent":[]}}],"position":{"start":{"line":293,"column":1,"offset":6950},"end":{"line":296,"column":88,"offset":7201},"indent":[1,1,1]}},{"type":"export","value":"export const _frontmatter = {\"title\":\"RDP Algoirthms\",\"date\":\"2020-05-19T00:00:00.000Z\",\"tags\":[\"Algorithms\"]}","position":{"start":{"line":299,"column":1,"offset":7204},"end":{"line":299,"column":111,"offset":7314},"indent":[]}}],"position":{"start":{"line":1,"column":1,"offset":0},"end":{"line":299,"column":111,"offset":7314}}},"scopeImports":["import * as React from 'react'"],"scopeIdentifiers":["React"],"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"RDP Algoirthms\",\n  \"date\": \"2020-05-19T00:00:00.000Z\",\n  \"tags\": [\"Algorithms\"]\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"The \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Ramer-Douglas\\u2013Peucker Algorithm\"), \" is a an algorithms that reduce the number of points that is approximated by a series of points. It is also known as the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Douglas\\u2013Peucker algorithm\"), \" and \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"iterative end-point fit algorithm\"), \". In simple words, it represent a complex line with fewer points in a visually proper way.\"), mdx(\"h3\", null, \"Overview\"), mdx(\"p\", null, \"The main purpose of this algorithm is to find a similar curve with fewer points for a given curve composed of line segments (also called \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Polylines\"), \"). This algorithm define 'disimilar' based on the maxium distance between the original curve and the simplied curve, i.e. the Hausdroff Distance. The Hausdroff distance is the longest distance you can be forced to travel by an adversary who chooses a point in one of the two sets, from where you then must travel to the other set. The simplified curve consist of a subset of points that defined the original curve.\"), mdx(\"h3\", null, \"How It Works\"), mdx(\"p\", null, \"Traversing a linked list means going through every single node of Linked List from \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"head\"), \" of the Linked List to the node which has \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"next\"), \" value pointing to None. Singly linked list can traversed in forward direction only starting from the first element.\"), mdx(\"p\", null, \"In the following program, we will print the the value of next data element by assigning the pointer of the next node to current data element :\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-python\"\n  }), \"class Node:\\n    def __init__(self, dataval=None):\\n        self.dataval = dataval\\n        self.nextval = None\\n\\nclass CLinkedList:\\n    def __init__(self):\\n        self.headval = None\\n\\n    def listprint(self):\\n        printval = self.headval\\n        while printval is not None:\\n            print (printval.dataval)\\n            printval = printval.nextval\\n\\nlt= CLinkedList()\\nlt.headval = Node(\\\"A\\\")\\ne2 = Node(\\\"B\\\")\\ne3 = Node(\\\"C\\\")\\ne4 = Node(\\\"D\\\")\\n\\n# Link first Node to second node\\nlt.headval.nextval = e2\\n\\n# Link second Node to third node\\ne2.nextval = e3\\n\\n# Link third Node to fourth node\\ne3.nextval = e4\\n\\nlt.listprint()\\n\")), mdx(\"p\", null, \"The output of the above code :\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"A\\nB\\nC\\nD\\n\")), mdx(\"h3\", null, \"How to insert a New Node ?\"), mdx(\"p\", null, \"Depending upon the location where you want to insert an item , there are different ways to insert item in the linked list.\"), mdx(\"h4\", null, \"Inserting at the beginning of the Linked List :\"), mdx(\"p\", null, \"This involves pointing the next node of next data to the current head of the Linked List. As a result, the current head of the linked list will become the second data element and the new node becomes the head of the linked list.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-python\"\n  }), \"class Node:\\n    def __init__(self, dataval=None):\\n        self.dataval = dataval\\n        self.nextval = None\\n\\nclass CLinkedList:\\n    def __init__(self):\\n        self.headval = None\\n\\n# Print the linked list\\n    def listprint(self):\\n        printval = self.headval\\n        while printval is not None:\\n            print (printval.dataval)\\n            printval = printval.nextval\\n    def AtBegining(self,newdata):\\n        NewNode = Node(newdata)\\n        # Update the new nodes next val to existing node\\n        NewNode.nextval = self.headval\\n        self.headval = NewNode\\n\\nlt = CLinkedList()\\nlt.headval = Node(\\\"A\\\")\\ne2 = Node(\\\"B\\\")\\ne3 = Node(\\\"C\\\")\\n\\nlt.headval.nextval = e2\\ne2.nextval = e3\\n\\nlt.AtBegining(\\\"Z\\\")\\n\\nlt.listprint()\\n\")), mdx(\"p\", null, \"The output of the above code :\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"Z\\nA\\nB\\nC\\n\")), mdx(\"h4\", null, \"Inserting at the end of Linked List :\"), mdx(\"p\", null, \"This involves pointing the next pointer of the current last node of the linked list to the new data. As a result, the current last node of the linked list becomes the second last node of the linked list and the new data node becomes the last node of the current linked list.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-python\"\n  }), \"class Node:\\n    def __init__(self, dataval=None):\\n        self.dataval = dataval\\n        self.nextval = None\\n\\nclass CLinkedList:\\n    def __init__(self):\\n        self.headval = None\\n\\n# Function to add newnode\\n    def AtEnd(self, newdata):\\n        NewNode = Node(newdata)\\n        if self.headval is None:\\n            self.headval = NewNode\\n            return\\n        laste = self.headval\\n        while(laste.nextval):\\n            laste = laste.nextval\\n        laste.nextval=NewNode\\n\\n# Print the linked list\\n    def listprint(self):\\n        printval = self.headval\\n        while printval is not None:\\n            print (printval.dataval)\\n            printval = printval.nextval\\n\\n\\nlt = CLinkedList()\\nlt.headval = Node(\\\"A\\\")\\ne2 = Node(\\\"B\\\")\\ne3 = Node(\\\"C\\\")\\n\\nlt.headval.nextval = e2\\ne2.nextval = e3\\n\\nlt.AtEnd(\\\"Z\\\")\\n\\nlt.listprint()\\n\")), mdx(\"p\", null, \"The output of the above code :\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"A\\nB\\nC\\nZ\\n\")), mdx(\"h4\", null, \"Inserting in between two Data Nodes :\"), mdx(\"p\", null, \"This involves pointing the next pointer of the specific node to the new node.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-python\"\n  }), \"class Node:\\n    def __init__(self, dataval=None):\\n        self.dataval = dataval\\n        self.nextval = None\\n\\nclass CLinkedList:\\n    def __init__(self):\\n        self.headval = None\\n\\n# Function to add node\\n    def Inbetween(self,middle_node,newdata):\\n        if middle_node is None:\\n            print(\\\"The mentioned node is absent\\\")\\n            return\\n\\n        NewNode = Node(newdata)\\n        NewNode.nextval = middle_node.nextval\\n        middle_node.nextval = NewNode\\n\\n# Print the linked list\\n    def listprint(self):\\n        printval = self.headval\\n        while printval is not None:\\n            print (printval.dataval)\\n            printval = printval.nextval\\n\\n\\nlt = CLinkedList()\\nlt.headval = Node(\\\"A\\\")\\ne2 = Node(\\\"B\\\")\\ne3 = Node(\\\"C\\\")\\n\\nlt.headval.nextval = e2\\ne2.nextval = e3\\n\\nlt.Inbetween(lt.headval.nextval,\\\"Z\\\")\\n\\nlt.listprint()\\n\")), mdx(\"p\", null, \"The output of the above code :\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"A\\nB\\nZ\\nC\\n\")), mdx(\"h3\", null, \"Removing  a Node from Linked List :\"), mdx(\"p\", null, \"To remove a node from the Linked List , we need to traverse the the list until we find our target node. Then we will link the pointer of the previous node of the target node to the next node of the target node.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-python\"\n  }), \"class Node:\\n    def __init__(self, data=None):\\n        self.data = data\\n        self.next = None\\n\\nclass CLinkedList:\\n    def __init__(self):\\n        self.head = None\\n\\n    def Atbegining(self, data_in):\\n        NewNode = Node(data_in)\\n        NewNode.next = self.head\\n        self.head = NewNode\\n\\n# Function to remove node\\n    def RemoveNode(self, Removekey):\\n\\n        HeadVal = self.head\\n\\n        if (HeadVal is not None):\\n            if (HeadVal.data == Removekey):\\n                self.head = HeadVal.next\\n                HeadVal = None\\n                return\\n\\n        while (HeadVal is not None):\\n            if HeadVal.data == Removekey:\\n                break\\n            prev = HeadVal\\n            HeadVal = HeadVal.next\\n\\n        if (HeadVal == None):\\n            return\\n\\n        prev.next = HeadVal.next\\n\\n        HeadVal = None\\n\\n    def LListprint(self):\\n        printval = self.head\\n        while (printval):\\n            print(printval.data),\\n            printval = printval.next\\n\\n\\nllist = CLinkedList()\\nllist.Atbegining(\\\"A\\\")\\nllist.Atbegining(\\\"B\\\")\\nllist.Atbegining(\\\"C\\\")\\nllist.Atbegining(\\\"D\\\")\\nllist.RemoveNode(\\\"B\\\")\\nllist.LListprint()\\n\")), mdx(\"p\", null, \"When the above code is executed, it produces the following result:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"A\\nC\\nD\\n\")), mdx(\"hr\", null), mdx(\"h2\", null, \"Author\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Hey, I\\u2019m Ayan, a backend software engineer. I write about what I know to help viewers like you. If you enjoy my content, please consider supporting what I do!\"), mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://ko-fi.com/B0B81M1SZ\"\n  }), mdx(\"img\", _extends({\n    parentName: \"a\"\n  }, {\n    \"src\": \"https://www.ko-fi.com/img/githubbutton_sm.svg\",\n    \"alt\": \"ko-fi\"\n  }))))));\n}\n;\nMDXContent.isMDXComponent = true;","rawMDXOutput":"/* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsx mdx */\n\nexport const _frontmatter = {\n  \"title\": \"RDP Algoirthms\",\n  \"date\": \"2020-05-19T00:00:00.000Z\",\n  \"tags\": [\"Algorithms\"]\n};\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\")\n  return <div {...props}/>\n};\n\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = \"wrapper\"\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n    <p>{`The `}<strong parentName=\"p\">{`Ramer-Douglas–Peucker Algorithm`}</strong>{` is a an algorithms that reduce the number of points that is approximated by a series of points. It is also known as the `}<strong parentName=\"p\">{`Douglas–Peucker algorithm`}</strong>{` and `}<strong parentName=\"p\">{`iterative end-point fit algorithm`}</strong>{`. In simple words, it represent a complex line with fewer points in a visually proper way.`}</p>\n    <h3>{`Overview`}</h3>\n    <p>{`The main purpose of this algorithm is to find a similar curve with fewer points for a given curve composed of line segments (also called `}<strong parentName=\"p\">{`Polylines`}</strong>{`). This algorithm define 'disimilar' based on the maxium distance between the original curve and the simplied curve, i.e. the Hausdroff Distance. The Hausdroff distance is the longest distance you can be forced to travel by an adversary who chooses a point in one of the two sets, from where you then must travel to the other set. The simplified curve consist of a subset of points that defined the original curve.`}</p>\n    <h3>{`How It Works`}</h3>\n    <p>{`Traversing a linked list means going through every single node of Linked List from `}<inlineCode parentName=\"p\">{`head`}</inlineCode>{` of the Linked List to the node which has `}<inlineCode parentName=\"p\">{`next`}</inlineCode>{` value pointing to None. Singly linked list can traversed in forward direction only starting from the first element.`}</p>\n    <p>{`In the following program, we will print the the value of next data element by assigning the pointer of the next node to current data element :`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-python\"\n      }}>{`class Node:\n    def __init__(self, dataval=None):\n        self.dataval = dataval\n        self.nextval = None\n\nclass CLinkedList:\n    def __init__(self):\n        self.headval = None\n\n    def listprint(self):\n        printval = self.headval\n        while printval is not None:\n            print (printval.dataval)\n            printval = printval.nextval\n\nlt= CLinkedList()\nlt.headval = Node(\"A\")\ne2 = Node(\"B\")\ne3 = Node(\"C\")\ne4 = Node(\"D\")\n\n# Link first Node to second node\nlt.headval.nextval = e2\n\n# Link second Node to third node\ne2.nextval = e3\n\n# Link third Node to fourth node\ne3.nextval = e4\n\nlt.listprint()\n`}</code></pre>\n    <p>{`The output of the above code :`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`A\nB\nC\nD\n`}</code></pre>\n    <h3>{`How to insert a New Node ?`}</h3>\n    <p>{`Depending upon the location where you want to insert an item , there are different ways to insert item in the linked list.`}</p>\n    <h4>{`Inserting at the beginning of the Linked List :`}</h4>\n    <p>{`This involves pointing the next node of next data to the current head of the Linked List. As a result, the current head of the linked list will become the second data element and the new node becomes the head of the linked list.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-python\"\n      }}>{`class Node:\n    def __init__(self, dataval=None):\n        self.dataval = dataval\n        self.nextval = None\n\nclass CLinkedList:\n    def __init__(self):\n        self.headval = None\n\n# Print the linked list\n    def listprint(self):\n        printval = self.headval\n        while printval is not None:\n            print (printval.dataval)\n            printval = printval.nextval\n    def AtBegining(self,newdata):\n        NewNode = Node(newdata)\n        # Update the new nodes next val to existing node\n        NewNode.nextval = self.headval\n        self.headval = NewNode\n\nlt = CLinkedList()\nlt.headval = Node(\"A\")\ne2 = Node(\"B\")\ne3 = Node(\"C\")\n\nlt.headval.nextval = e2\ne2.nextval = e3\n\nlt.AtBegining(\"Z\")\n\nlt.listprint()\n`}</code></pre>\n    <p>{`The output of the above code :`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`Z\nA\nB\nC\n`}</code></pre>\n    <h4>{`Inserting at the end of Linked List :`}</h4>\n    <p>{`This involves pointing the next pointer of the current last node of the linked list to the new data. As a result, the current last node of the linked list becomes the second last node of the linked list and the new data node becomes the last node of the current linked list.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-python\"\n      }}>{`class Node:\n    def __init__(self, dataval=None):\n        self.dataval = dataval\n        self.nextval = None\n\nclass CLinkedList:\n    def __init__(self):\n        self.headval = None\n\n# Function to add newnode\n    def AtEnd(self, newdata):\n        NewNode = Node(newdata)\n        if self.headval is None:\n            self.headval = NewNode\n            return\n        laste = self.headval\n        while(laste.nextval):\n            laste = laste.nextval\n        laste.nextval=NewNode\n\n# Print the linked list\n    def listprint(self):\n        printval = self.headval\n        while printval is not None:\n            print (printval.dataval)\n            printval = printval.nextval\n\n\nlt = CLinkedList()\nlt.headval = Node(\"A\")\ne2 = Node(\"B\")\ne3 = Node(\"C\")\n\nlt.headval.nextval = e2\ne2.nextval = e3\n\nlt.AtEnd(\"Z\")\n\nlt.listprint()\n`}</code></pre>\n    <p>{`The output of the above code :`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`A\nB\nC\nZ\n`}</code></pre>\n    <h4>{`Inserting in between two Data Nodes :`}</h4>\n    <p>{`This involves pointing the next pointer of the specific node to the new node.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-python\"\n      }}>{`class Node:\n    def __init__(self, dataval=None):\n        self.dataval = dataval\n        self.nextval = None\n\nclass CLinkedList:\n    def __init__(self):\n        self.headval = None\n\n# Function to add node\n    def Inbetween(self,middle_node,newdata):\n        if middle_node is None:\n            print(\"The mentioned node is absent\")\n            return\n\n        NewNode = Node(newdata)\n        NewNode.nextval = middle_node.nextval\n        middle_node.nextval = NewNode\n\n# Print the linked list\n    def listprint(self):\n        printval = self.headval\n        while printval is not None:\n            print (printval.dataval)\n            printval = printval.nextval\n\n\nlt = CLinkedList()\nlt.headval = Node(\"A\")\ne2 = Node(\"B\")\ne3 = Node(\"C\")\n\nlt.headval.nextval = e2\ne2.nextval = e3\n\nlt.Inbetween(lt.headval.nextval,\"Z\")\n\nlt.listprint()\n`}</code></pre>\n    <p>{`The output of the above code :`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`A\nB\nZ\nC\n`}</code></pre>\n    <h3>{`Removing  a Node from Linked List :`}</h3>\n    <p>{`To remove a node from the Linked List , we need to traverse the the list until we find our target node. Then we will link the pointer of the previous node of the target node to the next node of the target node.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-python\"\n      }}>{`class Node:\n    def __init__(self, data=None):\n        self.data = data\n        self.next = None\n\nclass CLinkedList:\n    def __init__(self):\n        self.head = None\n\n    def Atbegining(self, data_in):\n        NewNode = Node(data_in)\n        NewNode.next = self.head\n        self.head = NewNode\n\n# Function to remove node\n    def RemoveNode(self, Removekey):\n\n        HeadVal = self.head\n\n        if (HeadVal is not None):\n            if (HeadVal.data == Removekey):\n                self.head = HeadVal.next\n                HeadVal = None\n                return\n\n        while (HeadVal is not None):\n            if HeadVal.data == Removekey:\n                break\n            prev = HeadVal\n            HeadVal = HeadVal.next\n\n        if (HeadVal == None):\n            return\n\n        prev.next = HeadVal.next\n\n        HeadVal = None\n\n    def LListprint(self):\n        printval = self.head\n        while (printval):\n            print(printval.data),\n            printval = printval.next\n\n\nllist = CLinkedList()\nllist.Atbegining(\"A\")\nllist.Atbegining(\"B\")\nllist.Atbegining(\"C\")\nllist.Atbegining(\"D\")\nllist.RemoveNode(\"B\")\nllist.LListprint()\n`}</code></pre>\n    <p>{`When the above code is executed, it produces the following result:`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`A\nC\nD\n`}</code></pre>\n    <hr></hr>\n    <h2>{`Author`}</h2>\n    <blockquote>\n      <p parentName=\"blockquote\">{`Hey, I’m Ayan, a backend software engineer. I write about what I know to help viewers like you. If you enjoy my content, please consider supporting what I do!`}</p>\n      <p parentName=\"blockquote\"><a parentName=\"p\" {...{\n          \"href\": \"https://ko-fi.com/B0B81M1SZ\"\n        }}><img parentName=\"a\" {...{\n            \"src\": \"https://www.ko-fi.com/img/githubbutton_sm.svg\",\n            \"alt\": \"ko-fi\"\n          }}></img></a></p>\n    </blockquote>\n\n    </MDXLayout>;\n}\n\n;\nMDXContent.isMDXComponent = true;"}}