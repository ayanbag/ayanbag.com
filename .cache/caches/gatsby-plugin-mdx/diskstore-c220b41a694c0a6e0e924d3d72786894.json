{"expireTime":9007200844617659000,"key":"gatsby-plugin-mdx-entire-payload-09db0eccfdbfa7c891155ec4a983e03c-","val":{"mdast":{"type":"root","children":[{"type":"heading","depth":3,"children":[{"type":"text","value":"What is Loop in Linked List ?","position":{"start":{"line":2,"column":5,"offset":5},"end":{"line":2,"column":34,"offset":34},"indent":[]}}],"position":{"start":{"line":2,"column":1,"offset":1},"end":{"line":2,"column":34,"offset":34},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Generally, the last node of a Linked List points to ","position":{"start":{"line":4,"column":1,"offset":36},"end":{"line":4,"column":53,"offset":88},"indent":[]}},{"type":"inlineCode","value":"null","position":{"start":{"line":4,"column":53,"offset":88},"end":{"line":4,"column":59,"offset":94},"indent":[]}},{"type":"text","value":", which indicates that it is end of the list. But when there is a loop in a Linked List , the last node points to some of the interval node or first node or itself. In this case with we traverse a Linked List node one by one, our traversal will never end as it is in loop","position":{"start":{"line":4,"column":59,"offset":94},"end":{"line":4,"column":330,"offset":365},"indent":[]}}],"position":{"start":{"line":4,"column":1,"offset":36},"end":{"line":4,"column":330,"offset":365},"indent":[]}},{"type":"paragraph","children":[{"type":"image","title":null,"url":"https://user-images.githubusercontent.com/28982255/82292403-7a255f80-99c8-11ea-805c-2279f6544dd6.png","alt":"Loop in Linked List","position":{"start":{"line":6,"column":1,"offset":367},"end":{"line":6,"column":125,"offset":491},"indent":[]}}],"position":{"start":{"line":6,"column":1,"offset":367},"end":{"line":6,"column":125,"offset":491},"indent":[]}},{"type":"heading","depth":3,"children":[{"type":"text","value":"Detection of Loop in Linked List","position":{"start":{"line":9,"column":5,"offset":498},"end":{"line":9,"column":37,"offset":530},"indent":[]}}],"position":{"start":{"line":9,"column":1,"offset":494},"end":{"line":9,"column":37,"offset":530},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"There are many ways for detecting any cycle in linked list, ","position":{"start":{"line":11,"column":1,"offset":532},"end":{"line":11,"column":61,"offset":592},"indent":[]}},{"type":"strong","children":[{"type":"text","value":"Floyd Cycle Detection Algorithm","position":{"start":{"line":11,"column":63,"offset":594},"end":{"line":11,"column":94,"offset":625},"indent":[]}}],"position":{"start":{"line":11,"column":61,"offset":592},"end":{"line":11,"column":96,"offset":627},"indent":[]}},{"type":"text","value":" works better than other in terms of Time Complexity and Space Complexity. It is a pointer algorithm which uses only two pointers, which moves through the sequence. It is also called \"tortoise and the hare algorithm\".","position":{"start":{"line":11,"column":96,"offset":627},"end":{"line":11,"column":313,"offset":844},"indent":[]}}],"position":{"start":{"line":11,"column":1,"offset":532},"end":{"line":11,"column":313,"offset":844},"indent":[]}},{"type":"list","ordered":false,"start":null,"spread":false,"children":[{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"strong","children":[{"type":"text","value":"Space Complexity of Floyd Cycle Detection Algorithm :","position":{"start":{"line":13,"column":5,"offset":850},"end":{"line":13,"column":58,"offset":903},"indent":[]}}],"position":{"start":{"line":13,"column":3,"offset":848},"end":{"line":13,"column":60,"offset":905},"indent":[]}},{"type":"text","value":" O(1)","position":{"start":{"line":13,"column":60,"offset":905},"end":{"line":13,"column":65,"offset":910},"indent":[]}}],"position":{"start":{"line":13,"column":3,"offset":848},"end":{"line":13,"column":65,"offset":910},"indent":[]}}],"position":{"start":{"line":13,"column":1,"offset":846},"end":{"line":13,"column":65,"offset":910},"indent":[]}},{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"strong","children":[{"type":"text","value":"Time Complexity of Floyd Cycle Detection Algorithm :","position":{"start":{"line":14,"column":5,"offset":915},"end":{"line":14,"column":57,"offset":967},"indent":[]}}],"position":{"start":{"line":14,"column":3,"offset":913},"end":{"line":14,"column":59,"offset":969},"indent":[]}},{"type":"text","value":" O(n)","position":{"start":{"line":14,"column":59,"offset":969},"end":{"line":14,"column":64,"offset":974},"indent":[]}}],"position":{"start":{"line":14,"column":3,"offset":913},"end":{"line":14,"column":64,"offset":974},"indent":[]}}],"position":{"start":{"line":14,"column":1,"offset":911},"end":{"line":14,"column":64,"offset":974},"indent":[]}}],"position":{"start":{"line":13,"column":1,"offset":846},"end":{"line":14,"column":64,"offset":974},"indent":[1]}},{"type":"heading","depth":3,"children":[{"type":"text","value":"Working of Floyd Cycle Detection Algorithm and its Mathematical Proof","position":{"start":{"line":16,"column":5,"offset":980},"end":{"line":16,"column":74,"offset":1049},"indent":[]}}],"position":{"start":{"line":16,"column":1,"offset":976},"end":{"line":16,"column":74,"offset":1049},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"The logic of this algorithm can be illustrated as a race between a hare and a tortoise. Hare is always faster than a tortoise and it will always win the race against tortoise unless their is a cycle in the race track. If it exists in the race track, race will continue forever and hare will see tortoise again and again.","position":{"start":{"line":18,"column":1,"offset":1051},"end":{"line":18,"column":321,"offset":1371},"indent":[]}}],"position":{"start":{"line":18,"column":1,"offset":1051},"end":{"line":18,"column":321,"offset":1371},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Lets understand with the help of experiment :","position":{"start":{"line":20,"column":1,"offset":1373},"end":{"line":20,"column":46,"offset":1418},"indent":[]}}],"position":{"start":{"line":20,"column":1,"offset":1373},"end":{"line":20,"column":46,"offset":1418},"indent":[]}},{"type":"paragraph","children":[{"type":"image","title":null,"url":"https://user-images.githubusercontent.com/28982255/82298242-76e2a180-99d1-11ea-9dae-33449dcbbe0e.png","alt":"identify-start-node-of-loop-in-circular- linked-list 1","position":{"start":{"line":22,"column":1,"offset":1420},"end":{"line":22,"column":160,"offset":1579},"indent":[]}}],"position":{"start":{"line":22,"column":1,"offset":1420},"end":{"line":22,"column":160,"offset":1579},"indent":[]}},{"type":"list","ordered":false,"start":null,"spread":false,"children":[{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"Assuming the distance between the beginning node or head node of Linked List and starting node of the loop is ","position":{"start":{"line":25,"column":3,"offset":1584},"end":{"line":25,"column":113,"offset":1694},"indent":[]}},{"type":"strong","children":[{"type":"text","value":"a","position":{"start":{"line":25,"column":115,"offset":1696},"end":{"line":25,"column":116,"offset":1697},"indent":[]}}],"position":{"start":{"line":25,"column":113,"offset":1694},"end":{"line":25,"column":118,"offset":1699},"indent":[]}}],"position":{"start":{"line":25,"column":3,"offset":1584},"end":{"line":25,"column":118,"offset":1699},"indent":[]}}],"position":{"start":{"line":25,"column":1,"offset":1582},"end":{"line":25,"column":118,"offset":1699},"indent":[]}},{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"Assuming the distance between the starting node of the loop and meeting node of ","position":{"start":{"line":26,"column":3,"offset":1702},"end":{"line":26,"column":83,"offset":1782},"indent":[]}},{"type":"emphasis","children":[{"type":"text","value":"hare","position":{"start":{"line":26,"column":84,"offset":1783},"end":{"line":26,"column":88,"offset":1787},"indent":[]}}],"position":{"start":{"line":26,"column":83,"offset":1782},"end":{"line":26,"column":89,"offset":1788},"indent":[]}},{"type":"text","value":" and ","position":{"start":{"line":26,"column":89,"offset":1788},"end":{"line":26,"column":94,"offset":1793},"indent":[]}},{"type":"emphasis","children":[{"type":"text","value":"tortoise","position":{"start":{"line":26,"column":95,"offset":1794},"end":{"line":26,"column":103,"offset":1802},"indent":[]}}],"position":{"start":{"line":26,"column":94,"offset":1793},"end":{"line":26,"column":104,"offset":1803},"indent":[]}},{"type":"text","value":" is ","position":{"start":{"line":26,"column":104,"offset":1803},"end":{"line":26,"column":108,"offset":1807},"indent":[]}},{"type":"strong","children":[{"type":"text","value":"b","position":{"start":{"line":26,"column":110,"offset":1809},"end":{"line":26,"column":111,"offset":1810},"indent":[]}}],"position":{"start":{"line":26,"column":108,"offset":1807},"end":{"line":26,"column":113,"offset":1812},"indent":[]}}],"position":{"start":{"line":26,"column":3,"offset":1702},"end":{"line":26,"column":113,"offset":1812},"indent":[]}}],"position":{"start":{"line":26,"column":1,"offset":1700},"end":{"line":26,"column":113,"offset":1812},"indent":[]}},{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"Assuming the distance between the meeting node of ","position":{"start":{"line":27,"column":3,"offset":1815},"end":{"line":27,"column":53,"offset":1865},"indent":[]}},{"type":"emphasis","children":[{"type":"text","value":"hare","position":{"start":{"line":27,"column":54,"offset":1866},"end":{"line":27,"column":58,"offset":1870},"indent":[]}}],"position":{"start":{"line":27,"column":53,"offset":1865},"end":{"line":27,"column":59,"offset":1871},"indent":[]}},{"type":"text","value":" and ","position":{"start":{"line":27,"column":59,"offset":1871},"end":{"line":27,"column":64,"offset":1876},"indent":[]}},{"type":"emphasis","children":[{"type":"text","value":"tortoise","position":{"start":{"line":27,"column":65,"offset":1877},"end":{"line":27,"column":73,"offset":1885},"indent":[]}}],"position":{"start":{"line":27,"column":64,"offset":1876},"end":{"line":27,"column":74,"offset":1886},"indent":[]}},{"type":"text","value":" and starting node  of the loop is ","position":{"start":{"line":27,"column":74,"offset":1886},"end":{"line":27,"column":109,"offset":1921},"indent":[]}},{"type":"strong","children":[{"type":"text","value":"c","position":{"start":{"line":27,"column":111,"offset":1923},"end":{"line":27,"column":112,"offset":1924},"indent":[]}}],"position":{"start":{"line":27,"column":109,"offset":1921},"end":{"line":27,"column":114,"offset":1926},"indent":[]}}],"position":{"start":{"line":27,"column":3,"offset":1815},"end":{"line":27,"column":114,"offset":1926},"indent":[]}}],"position":{"start":{"line":27,"column":1,"offset":1813},"end":{"line":27,"column":114,"offset":1926},"indent":[]}}],"position":{"start":{"line":25,"column":1,"offset":1582},"end":{"line":27,"column":114,"offset":1926},"indent":[1,1]}},{"type":"paragraph","children":[{"type":"text","value":"Tortoise moves one node at a time and the hare moves two node at same time. So, we can say when the tortoise has moved distance ","position":{"start":{"line":29,"column":1,"offset":1928},"end":{"line":29,"column":129,"offset":2056},"indent":[]}},{"type":"strong","children":[{"type":"text","value":"d","position":{"start":{"line":29,"column":131,"offset":2058},"end":{"line":29,"column":132,"offset":2059},"indent":[]}}],"position":{"start":{"line":29,"column":129,"offset":2056},"end":{"line":29,"column":134,"offset":2061},"indent":[]}},{"type":"text","value":" , then turtle has moved pointer ","position":{"start":{"line":29,"column":134,"offset":2061},"end":{"line":29,"column":167,"offset":2094},"indent":[]}},{"type":"strong","children":[{"type":"text","value":"2d","position":{"start":{"line":29,"column":169,"offset":2096},"end":{"line":29,"column":171,"offset":2098},"indent":[]}}],"position":{"start":{"line":29,"column":167,"offset":2094},"end":{"line":29,"column":173,"offset":2100},"indent":[]}},{"type":"text","value":".","position":{"start":{"line":29,"column":173,"offset":2100},"end":{"line":29,"column":174,"offset":2101},"indent":[]}}],"position":{"start":{"line":29,"column":1,"offset":1928},"end":{"line":29,"column":174,"offset":2101},"indent":[]}},{"type":"code","lang":"latex","meta":null,"value":"So the length of the loop is b+c\n\nWhen both tortoise and hare meets, tortoise covers a distance d = a+b and\nhare covers a distace 2d = (a+b+c+b)\n\nTherefore,\n2*d = (a+b+c+b)\nd = (a+b)\n\nNow,\n=> 2*d = 2*(a+b)\n=> 2*(a+b) = (a+b+c+b)\n=> 2*a + 2*b = a+2*b+c\n=> a=c\n\nIt means distance from head node to the start of loop node is same as distance between meeting point of the tortoise and hare to the starting node of loop","position":{"start":{"line":31,"column":1,"offset":2103},"end":{"line":48,"column":4,"offset":2530},"indent":[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"So this shows after getting meeting point, if one pointer is placed at the beginning of the list, then moving both pointer one node at a time then they will meet at the start of loop.","position":{"start":{"line":50,"column":1,"offset":2532},"end":{"line":50,"column":184,"offset":2715},"indent":[]}}],"position":{"start":{"line":50,"column":1,"offset":2532},"end":{"line":50,"column":184,"offset":2715},"indent":[]}},{"type":"heading","depth":3,"children":[{"type":"text","value":"Implementation of Floyd Cycle Detection Algorithm","position":{"start":{"line":54,"column":5,"offset":2723},"end":{"line":54,"column":54,"offset":2772},"indent":[]}}],"position":{"start":{"line":54,"column":1,"offset":2719},"end":{"line":54,"column":54,"offset":2772},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Implementation in ","position":{"start":{"line":56,"column":1,"offset":2774},"end":{"line":56,"column":19,"offset":2792},"indent":[]}},{"type":"strong","children":[{"type":"text","value":"Python","position":{"start":{"line":56,"column":21,"offset":2794},"end":{"line":56,"column":27,"offset":2800},"indent":[]}}],"position":{"start":{"line":56,"column":19,"offset":2792},"end":{"line":56,"column":29,"offset":2802},"indent":[]}},{"type":"text","value":"  :","position":{"start":{"line":56,"column":29,"offset":2802},"end":{"line":56,"column":32,"offset":2805},"indent":[]}}],"position":{"start":{"line":56,"column":1,"offset":2774},"end":{"line":56,"column":32,"offset":2805},"indent":[]}},{"type":"code","lang":"python","meta":null,"value":"\n# Node class\nclass Node:\n\n    # Constructor to initialize the node object\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\nclass LinkedList:\n\n    # Function to initialize head\n    def __init__(self):\n        self.head = None\n\n    # Function to insert a new node at the beginning\n    def push(self, new_data):\n        new_node = Node(new_data)\n        new_node.next = self.head\n        self.head = new_node\n\n    # Utility function to print it the linked LinkedList\n    def printList(self):\n        temp = self.head\n        while(temp):\n            print temp.data,\n            temp = temp.next\n\n\n    def detectLoop(self):\n        slow_p = self.head\n        fast_p = self.head\n        while(slow_p and fast_p and fast_p.next):\n            slow_p = slow_p.next\n            fast_p = fast_p.next.next\n            if slow_p == fast_p:\n                print \"Found Loop\"\n                return\n\n# Driver program for testing\nllist = LinkedList()\nllist.push(20)\nllist.push(4)\nllist.push(15)\nllist.push(10)\n\n# Create a loop for testing\nllist.head.next.next.next.next = llist.head\nllist.detectLoop()","position":{"start":{"line":58,"column":1,"offset":2807},"end":{"line":108,"column":4,"offset":3942},"indent":[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"Output :","position":{"start":{"line":109,"column":1,"offset":3943},"end":{"line":109,"column":9,"offset":3951},"indent":[]}}],"position":{"start":{"line":109,"column":1,"offset":3943},"end":{"line":109,"column":9,"offset":3951},"indent":[]}},{"type":"code","lang":null,"meta":null,"value":"Found Loop","position":{"start":{"line":110,"column":1,"offset":3952},"end":{"line":112,"column":4,"offset":3970},"indent":[1,1]}},{"type":"paragraph","children":[{"type":"text","value":"Implementation in ","position":{"start":{"line":116,"column":1,"offset":3974},"end":{"line":116,"column":19,"offset":3992},"indent":[]}},{"type":"strong","children":[{"type":"text","value":"Java","position":{"start":{"line":116,"column":21,"offset":3994},"end":{"line":116,"column":25,"offset":3998},"indent":[]}}],"position":{"start":{"line":116,"column":19,"offset":3992},"end":{"line":116,"column":27,"offset":4000},"indent":[]}},{"type":"text","value":":","position":{"start":{"line":116,"column":27,"offset":4000},"end":{"line":116,"column":28,"offset":4001},"indent":[]}}],"position":{"start":{"line":116,"column":1,"offset":3974},"end":{"line":116,"column":28,"offset":4001},"indent":[]}},{"type":"code","lang":"java","meta":null,"value":"class LinkedList {\n    Node head; // head of list\n\n    /* Linked list Node*/\n    class Node {\n        int data;\n        Node next;\n        Node(int d)\n        {\n            data = d;\n            next = null;\n        }\n    }\n\n    /* Inserts a new Node at front of the list. */\n    public void push(int new_data)\n    {\n        /* 1 & 2: Allocate the Node &\n                  Put in the data*/\n        Node new_node = new Node(new_data);\n\n        /* 3. Make next of new Node as head */\n        new_node.next = head;\n\n        /* 4. Move the head to point to new Node */\n        head = new_node;\n    }\n\n    int detectLoop()\n    {\n        Node slow_p = head, fast_p = head;\n        while (slow_p != null && fast_p != null && fast_p.next != null) {\n            slow_p = slow_p.next;\n            fast_p = fast_p.next.next;\n            if (slow_p == fast_p) {\n                System.out.println(\"Found loop\");\n                return 1;\n            }\n        }\n        return 0;\n    }\n\n    /* Driver program to test above functions */\n    public static void main(String args[])\n    {\n        LinkedList llist = new LinkedList();\n\n        llist.push(20);\n        llist.push(4);\n        llist.push(15);\n        llist.push(10);\n\n        /*Create loop for testing */\n        llist.head.next.next.next.next = llist.head;\n\n        llist.detectLoop();\n    }\n}","position":{"start":{"line":118,"column":1,"offset":4003},"end":{"line":177,"column":4,"offset":5357},"indent":[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"Output :","position":{"start":{"line":179,"column":1,"offset":5359},"end":{"line":179,"column":9,"offset":5367},"indent":[]}}],"position":{"start":{"line":179,"column":1,"offset":5359},"end":{"line":179,"column":9,"offset":5367},"indent":[]}},{"type":"code","lang":null,"meta":null,"value":"Found Loop","position":{"start":{"line":180,"column":1,"offset":5368},"end":{"line":182,"column":4,"offset":5386},"indent":[1,1]}},{"type":"export","value":"export const _frontmatter = {\"title\":\"Floyd Cycle Detection Algorithm\",\"date\":\"2020-05-19T00:00:00.000Z\",\"tags\":[\"Algorithms\"]}","position":{"start":{"line":185,"column":1,"offset":5389},"end":{"line":185,"column":128,"offset":5516},"indent":[]}}],"position":{"start":{"line":1,"column":1,"offset":0},"end":{"line":185,"column":128,"offset":5516}}},"scopeImports":["import * as React from 'react'"],"scopeIdentifiers":["React"],"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Floyd Cycle Detection Algorithm\",\n  \"date\": \"2020-05-19T00:00:00.000Z\",\n  \"tags\": [\"Algorithms\"]\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h3\", null, \"What is Loop in Linked List ?\"), mdx(\"p\", null, \"Generally, the last node of a Linked List points to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"null\"), \", which indicates that it is end of the list. But when there is a loop in a Linked List , the last node points to some of the interval node or first node or itself. In this case with we traverse a Linked List node one by one, our traversal will never end as it is in loop\"), mdx(\"p\", null, mdx(\"img\", _extends({\n    parentName: \"p\"\n  }, {\n    \"src\": \"https://user-images.githubusercontent.com/28982255/82292403-7a255f80-99c8-11ea-805c-2279f6544dd6.png\",\n    \"alt\": \"Loop in Linked List\"\n  }))), mdx(\"h3\", null, \"Detection of Loop in Linked List\"), mdx(\"p\", null, \"There are many ways for detecting any cycle in linked list, \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Floyd Cycle Detection Algorithm\"), \" works better than other in terms of Time Complexity and Space Complexity. It is a pointer algorithm which uses only two pointers, which moves through the sequence. It is also called \\\"tortoise and the hare algorithm\\\".\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Space Complexity of Floyd Cycle Detection Algorithm :\"), \" O(1)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Time Complexity of Floyd Cycle Detection Algorithm :\"), \" O(n)\")), mdx(\"h3\", null, \"Working of Floyd Cycle Detection Algorithm and its Mathematical Proof\"), mdx(\"p\", null, \"The logic of this algorithm can be illustrated as a race between a hare and a tortoise. Hare is always faster than a tortoise and it will always win the race against tortoise unless their is a cycle in the race track. If it exists in the race track, race will continue forever and hare will see tortoise again and again.\"), mdx(\"p\", null, \"Lets understand with the help of experiment :\"), mdx(\"p\", null, mdx(\"img\", _extends({\n    parentName: \"p\"\n  }, {\n    \"src\": \"https://user-images.githubusercontent.com/28982255/82298242-76e2a180-99d1-11ea-9dae-33449dcbbe0e.png\",\n    \"alt\": \"identify-start-node-of-loop-in-circular- linked-list 1\"\n  }))), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Assuming the distance between the beginning node or head node of Linked List and starting node of the loop is \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"a\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Assuming the distance between the starting node of the loop and meeting node of \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"hare\"), \" and \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"tortoise\"), \" is \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"b\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Assuming the distance between the meeting node of \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"hare\"), \" and \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"tortoise\"), \" and starting node  of the loop is \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"c\"))), mdx(\"p\", null, \"Tortoise moves one node at a time and the hare moves two node at same time. So, we can say when the tortoise has moved distance \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"d\"), \" , then turtle has moved pointer \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"2d\"), \".\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-latex\"\n  }), \"So the length of the loop is b+c\\n\\nWhen both tortoise and hare meets, tortoise covers a distance d = a+b and\\nhare covers a distace 2d = (a+b+c+b)\\n\\nTherefore,\\n2*d = (a+b+c+b)\\nd = (a+b)\\n\\nNow,\\n=> 2*d = 2*(a+b)\\n=> 2*(a+b) = (a+b+c+b)\\n=> 2*a + 2*b = a+2*b+c\\n=> a=c\\n\\nIt means distance from head node to the start of loop node is same as distance between meeting point of the tortoise and hare to the starting node of loop\\n\")), mdx(\"p\", null, \"So this shows after getting meeting point, if one pointer is placed at the beginning of the list, then moving both pointer one node at a time then they will meet at the start of loop.\"), mdx(\"h3\", null, \"Implementation of Floyd Cycle Detection Algorithm\"), mdx(\"p\", null, \"Implementation in \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Python\"), \"  :\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-python\"\n  }), \"\\n# Node class\\nclass Node:\\n\\n    # Constructor to initialize the node object\\n    def __init__(self, data):\\n        self.data = data\\n        self.next = None\\n\\nclass LinkedList:\\n\\n    # Function to initialize head\\n    def __init__(self):\\n        self.head = None\\n\\n    # Function to insert a new node at the beginning\\n    def push(self, new_data):\\n        new_node = Node(new_data)\\n        new_node.next = self.head\\n        self.head = new_node\\n\\n    # Utility function to print it the linked LinkedList\\n    def printList(self):\\n        temp = self.head\\n        while(temp):\\n            print temp.data,\\n            temp = temp.next\\n\\n\\n    def detectLoop(self):\\n        slow_p = self.head\\n        fast_p = self.head\\n        while(slow_p and fast_p and fast_p.next):\\n            slow_p = slow_p.next\\n            fast_p = fast_p.next.next\\n            if slow_p == fast_p:\\n                print \\\"Found Loop\\\"\\n                return\\n\\n# Driver program for testing\\nllist = LinkedList()\\nllist.push(20)\\nllist.push(4)\\nllist.push(15)\\nllist.push(10)\\n\\n# Create a loop for testing\\nllist.head.next.next.next.next = llist.head\\nllist.detectLoop()\\n\")), mdx(\"p\", null, \"Output :\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"Found Loop\\n\")), mdx(\"p\", null, \"Implementation in \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Java\"), \":\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-java\"\n  }), \"class LinkedList {\\n    Node head; // head of list\\n\\n    /* Linked list Node*/\\n    class Node {\\n        int data;\\n        Node next;\\n        Node(int d)\\n        {\\n            data = d;\\n            next = null;\\n        }\\n    }\\n\\n    /* Inserts a new Node at front of the list. */\\n    public void push(int new_data)\\n    {\\n        /* 1 & 2: Allocate the Node &\\n                  Put in the data*/\\n        Node new_node = new Node(new_data);\\n\\n        /* 3. Make next of new Node as head */\\n        new_node.next = head;\\n\\n        /* 4. Move the head to point to new Node */\\n        head = new_node;\\n    }\\n\\n    int detectLoop()\\n    {\\n        Node slow_p = head, fast_p = head;\\n        while (slow_p != null && fast_p != null && fast_p.next != null) {\\n            slow_p = slow_p.next;\\n            fast_p = fast_p.next.next;\\n            if (slow_p == fast_p) {\\n                System.out.println(\\\"Found loop\\\");\\n                return 1;\\n            }\\n        }\\n        return 0;\\n    }\\n\\n    /* Driver program to test above functions */\\n    public static void main(String args[])\\n    {\\n        LinkedList llist = new LinkedList();\\n\\n        llist.push(20);\\n        llist.push(4);\\n        llist.push(15);\\n        llist.push(10);\\n\\n        /*Create loop for testing */\\n        llist.head.next.next.next.next = llist.head;\\n\\n        llist.detectLoop();\\n    }\\n}\\n\")), mdx(\"p\", null, \"Output :\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"Found Loop\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;","rawMDXOutput":"/* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsx mdx */\n\nexport const _frontmatter = {\n  \"title\": \"Floyd Cycle Detection Algorithm\",\n  \"date\": \"2020-05-19T00:00:00.000Z\",\n  \"tags\": [\"Algorithms\"]\n};\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\")\n  return <div {...props}/>\n};\n\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = \"wrapper\"\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n    <h3>{`What is Loop in Linked List ?`}</h3>\n    <p>{`Generally, the last node of a Linked List points to `}<inlineCode parentName=\"p\">{`null`}</inlineCode>{`, which indicates that it is end of the list. But when there is a loop in a Linked List , the last node points to some of the interval node or first node or itself. In this case with we traverse a Linked List node one by one, our traversal will never end as it is in loop`}</p>\n    <p><img parentName=\"p\" {...{\n        \"src\": \"https://user-images.githubusercontent.com/28982255/82292403-7a255f80-99c8-11ea-805c-2279f6544dd6.png\",\n        \"alt\": \"Loop in Linked List\"\n      }}></img></p>\n    <h3>{`Detection of Loop in Linked List`}</h3>\n    <p>{`There are many ways for detecting any cycle in linked list, `}<strong parentName=\"p\">{`Floyd Cycle Detection Algorithm`}</strong>{` works better than other in terms of Time Complexity and Space Complexity. It is a pointer algorithm which uses only two pointers, which moves through the sequence. It is also called \"tortoise and the hare algorithm\".`}</p>\n    <ul>\n      <li parentName=\"ul\"><strong parentName=\"li\">{`Space Complexity of Floyd Cycle Detection Algorithm :`}</strong>{` O(1)`}</li>\n      <li parentName=\"ul\"><strong parentName=\"li\">{`Time Complexity of Floyd Cycle Detection Algorithm :`}</strong>{` O(n)`}</li>\n    </ul>\n    <h3>{`Working of Floyd Cycle Detection Algorithm and its Mathematical Proof`}</h3>\n    <p>{`The logic of this algorithm can be illustrated as a race between a hare and a tortoise. Hare is always faster than a tortoise and it will always win the race against tortoise unless their is a cycle in the race track. If it exists in the race track, race will continue forever and hare will see tortoise again and again.`}</p>\n    <p>{`Lets understand with the help of experiment :`}</p>\n    <p><img parentName=\"p\" {...{\n        \"src\": \"https://user-images.githubusercontent.com/28982255/82298242-76e2a180-99d1-11ea-9dae-33449dcbbe0e.png\",\n        \"alt\": \"identify-start-node-of-loop-in-circular- linked-list 1\"\n      }}></img></p>\n    <ul>\n      <li parentName=\"ul\">{`Assuming the distance between the beginning node or head node of Linked List and starting node of the loop is `}<strong parentName=\"li\">{`a`}</strong></li>\n      <li parentName=\"ul\">{`Assuming the distance between the starting node of the loop and meeting node of `}<em parentName=\"li\">{`hare`}</em>{` and `}<em parentName=\"li\">{`tortoise`}</em>{` is `}<strong parentName=\"li\">{`b`}</strong></li>\n      <li parentName=\"ul\">{`Assuming the distance between the meeting node of `}<em parentName=\"li\">{`hare`}</em>{` and `}<em parentName=\"li\">{`tortoise`}</em>{` and starting node  of the loop is `}<strong parentName=\"li\">{`c`}</strong></li>\n    </ul>\n    <p>{`Tortoise moves one node at a time and the hare moves two node at same time. So, we can say when the tortoise has moved distance `}<strong parentName=\"p\">{`d`}</strong>{` , then turtle has moved pointer `}<strong parentName=\"p\">{`2d`}</strong>{`.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-latex\"\n      }}>{`So the length of the loop is b+c\n\nWhen both tortoise and hare meets, tortoise covers a distance d = a+b and\nhare covers a distace 2d = (a+b+c+b)\n\nTherefore,\n2*d = (a+b+c+b)\nd = (a+b)\n\nNow,\n=> 2*d = 2*(a+b)\n=> 2*(a+b) = (a+b+c+b)\n=> 2*a + 2*b = a+2*b+c\n=> a=c\n\nIt means distance from head node to the start of loop node is same as distance between meeting point of the tortoise and hare to the starting node of loop\n`}</code></pre>\n    <p>{`So this shows after getting meeting point, if one pointer is placed at the beginning of the list, then moving both pointer one node at a time then they will meet at the start of loop.`}</p>\n    <h3>{`Implementation of Floyd Cycle Detection Algorithm`}</h3>\n    <p>{`Implementation in `}<strong parentName=\"p\">{`Python`}</strong>{`  :`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-python\"\n      }}>{`\n# Node class\nclass Node:\n\n    # Constructor to initialize the node object\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\nclass LinkedList:\n\n    # Function to initialize head\n    def __init__(self):\n        self.head = None\n\n    # Function to insert a new node at the beginning\n    def push(self, new_data):\n        new_node = Node(new_data)\n        new_node.next = self.head\n        self.head = new_node\n\n    # Utility function to print it the linked LinkedList\n    def printList(self):\n        temp = self.head\n        while(temp):\n            print temp.data,\n            temp = temp.next\n\n\n    def detectLoop(self):\n        slow_p = self.head\n        fast_p = self.head\n        while(slow_p and fast_p and fast_p.next):\n            slow_p = slow_p.next\n            fast_p = fast_p.next.next\n            if slow_p == fast_p:\n                print \"Found Loop\"\n                return\n\n# Driver program for testing\nllist = LinkedList()\nllist.push(20)\nllist.push(4)\nllist.push(15)\nllist.push(10)\n\n# Create a loop for testing\nllist.head.next.next.next.next = llist.head\nllist.detectLoop()\n`}</code></pre>\n    <p>{`Output :`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`Found Loop\n`}</code></pre>\n    <p>{`Implementation in `}<strong parentName=\"p\">{`Java`}</strong>{`:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-java\"\n      }}>{`class LinkedList {\n    Node head; // head of list\n\n    /* Linked list Node*/\n    class Node {\n        int data;\n        Node next;\n        Node(int d)\n        {\n            data = d;\n            next = null;\n        }\n    }\n\n    /* Inserts a new Node at front of the list. */\n    public void push(int new_data)\n    {\n        /* 1 & 2: Allocate the Node &\n                  Put in the data*/\n        Node new_node = new Node(new_data);\n\n        /* 3. Make next of new Node as head */\n        new_node.next = head;\n\n        /* 4. Move the head to point to new Node */\n        head = new_node;\n    }\n\n    int detectLoop()\n    {\n        Node slow_p = head, fast_p = head;\n        while (slow_p != null && fast_p != null && fast_p.next != null) {\n            slow_p = slow_p.next;\n            fast_p = fast_p.next.next;\n            if (slow_p == fast_p) {\n                System.out.println(\"Found loop\");\n                return 1;\n            }\n        }\n        return 0;\n    }\n\n    /* Driver program to test above functions */\n    public static void main(String args[])\n    {\n        LinkedList llist = new LinkedList();\n\n        llist.push(20);\n        llist.push(4);\n        llist.push(15);\n        llist.push(10);\n\n        /*Create loop for testing */\n        llist.head.next.next.next.next = llist.head;\n\n        llist.detectLoop();\n    }\n}\n`}</code></pre>\n    <p>{`Output :`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`Found Loop\n`}</code></pre>\n\n    </MDXLayout>;\n}\n\n;\nMDXContent.isMDXComponent = true;"}}